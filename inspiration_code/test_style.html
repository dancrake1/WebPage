<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Grid Paper + Fast Static Fill (Test)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root{
      /* Six fixed hex values — swap to your palette; order permutes per session */
      --c0:#1f2328; --c1:#e64f3a; --c2:#1766a6; --c3:#f0be55; --c4:#8aa57a; --c5:#d9d4c8;
      --bg:#f6f6f3;
      --ink:#1f2328;
      --grid-minor:#0b1b2a;  /* cool ink for “math paper” vibe */
      --grid-major:#0b1b2a;
    }
    html,body{height:100%;margin:0;background:var(--bg)}
    #gridStage, #overlay {
      position:fixed; inset:0; display:block;
    }
    #gridStage{ z-index:0; background:var(--bg); }
    #overlay{ z-index:1; pointer-events:none; }

    /* Demo foreground */
    .chrome{
      position:relative; z-index:2; min-height:100vh;
      display:grid; grid-template-columns: 1fr minmax(320px,520px);
      gap:2rem; padding:clamp(16px,4vw,40px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#121212;
    }
    h1{margin:0 0 .2em; font-weight:800; font-size:clamp(28px,5vw,56px); letter-spacing:-.01em}
    p{max-width:50ch; opacity:.9}
    .toolbar{margin-top:14px; display:flex; gap:10px; flex-wrap:wrap}
    .toolbar button{border:1px solid #0002; background:#fff; padding:.55rem .8rem; border-radius:999px; cursor:pointer}

    /* HERO SAFE AREA (pretend this is your homepage image) */
    .hero{
      position:relative; align-self:start;
      width:min(40vw,520px); height:min(60vh,620px); justify-self:end;
    }
    .hero::before{
      content:""; position:absolute; inset:0; border-radius:22px;
      background:#ffffffb8; border:1px solid #00000012; box-shadow:0 20px 60px #00000018; backdrop-filter:saturate(1.05) blur(1px);
    }
    .hero figcaption{
      position:absolute; bottom:10px; left:14px; font-size:12px; color:#111; background:#fff8; padding:6px 10px; border-radius:10px; border:1px solid #00000014;
    }
  </style>
</head>
<body>
  <canvas id="gridStage" aria-hidden="true"></canvas>
  <canvas id="overlay" aria-hidden="true"></canvas>

  <main class="chrome">
    <section>
      <h1>Math Grid + “Boot” Static</h1>
      <p>Thinner, graph-paper lines (minor/major). Faster, old-computer fill: cells flicker briefly, then commit. New composition on reload; palette fixed per session.</p>
      <div class="toolbar">
        <button id="regen">Regenerate</button>
        <button id="pause">Pause</button>
        <small style="opacity:.6">Respects <code>prefers-reduced-motion</code>.</small>
      </div>
    </section>
    <figure class="hero" id="hero"><figcaption>Hero image safe area</figcaption></figure>
  </main>

  <script>
  /* ==============================
     Tunables (adjust to taste)
  ===============================*/
  const CFG = {
    targetCell: 28,                // ≈ graph paper spacing
    minorOpacity: 0.10,            // very thin minor lines
    majorOpacity: 0.22,            // slightly darker major lines
    majorEvery: 5,                 // a bold line every N cells
    lineWidthMinor: 1,             // hairline (crisp via 0.5 offset)
    lineWidthMajor: 1,             // keep thin; just darker
    coverageTarget: 0.82,

    // “Old computer” feel — faster cadence + flicker
    initialDelay: 120,             // show pure grid briefly
    burst: {min:22, max:52},       // fills per burst (fast)
    pace: {min:40, max:110},       // ms between bursts (fast)
    afterIdlePace: {min:300, max:700},
    flickerSteps: [2,3,4],         // how many pre-flickers before final
    flickerTotalMs: 140,           // total flicker time inside a cell
    jitterPx: 0.7,                 // tiny in-cell jitter per flicker draw

    skipHero: true,                // hard-skip under hero
    attenuateUnderHero: 0.55,      // if skipHero=false, dim fills under hero
  };

  /* ==============================
     Seeded RNG (Mulberry32)
  ===============================*/
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  let SESSION_SEED = (crypto?.getRandomValues) ? crypto.getRandomValues(new Uint32Array(1))[0] : (Date.now()>>>0);
  let rand = mulberry32(SESSION_SEED);
  function randRange(a,b){ return a + (b-a)*rand(); }
  function choice(arr){ return arr[Math.floor(rand()*arr.length)] }

  /* ==============================
     Palette (six fixed per session)
  ===============================*/
  const basePalette = ['--c0','--c1','--c2','--c3','--c4','--c5']
    .map(v => getComputedStyle(document.documentElement).getPropertyValue(v).trim());
  function shuffleDet(a){ const x=a.slice(); for(let i=x.length-1;i>0;i--){ const j=Math.floor(rand()*(i+1)); [x[i],x[j]]=[x[j],x[i]] } return x; }
  const palette = shuffleDet(basePalette);

  /* ==============================
     Canvas setup
  ===============================*/
  const stage = document.getElementById('gridStage');
  const ctx = stage.getContext('2d');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');
  let DPR=1, W=0, H=0, cols=0, rows=0, cell=CFG.targetCell;

  const heroEl = document.getElementById('hero');
  function heroRect(){ const r = heroEl.getBoundingClientRect(); return {x:r.left,y:r.top,w:r.width,h:r.height}; }

  function resize(){
    const r = stage.getBoundingClientRect();
    W = Math.floor(r.width); H = Math.floor(r.height);
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    [stage, overlay].forEach(c=>{ c.width=Math.floor(W*DPR); c.height=Math.floor(H*DPR); });
    ctx.setTransform(DPR,0,0,DPR,0,0); octx.setTransform(DPR,0,0,DPR,0,0);

    cell = Math.max(16, Math.round(CFG.targetCell * (W/1200 + 0.25)));
    cols = Math.max(8, Math.floor(W / cell));
    rows = Math.max(8, Math.floor(H / cell));

    filled.clear(); order.length=0;
    drawGridPaper();
    composeTraversal();
    // restart overlay animation (scanline shimmer)
    startOverlay();
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) renderReduced();
    else scheduleNextBurst(CFG.initialDelay);
  }

  /* ==============================
     Grid paper (minor + major lines)
  ===============================*/
  function drawGridPaper(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
    ctx.fillRect(0,0,W,H);

    const minor = getComputedStyle(document.documentElement).getPropertyValue('--grid-minor').trim();
    const major = getComputedStyle(document.documentElement).getPropertyValue('--grid-major').trim();

    // Minor lines
    ctx.save();
    ctx.lineWidth = CFG.lineWidthMinor;
    ctx.strokeStyle = `color-mix(in srgb, ${minor} ${CFG.minorOpacity*100}%, transparent)`;
    ctx.beginPath();
    for(let i=0;i<=cols;i++){ const x=Math.round(i*cell)+.5; ctx.moveTo(x,0); ctx.lineTo(x,rows*cell); }
    for(let j=0;j<=rows;j++){ const y=Math.round(j*cell)+.5; ctx.moveTo(0,y); ctx.lineTo(cols*cell,y); }
    ctx.stroke();
    ctx.restore();

    // Major lines every N
    ctx.save();
    ctx.lineWidth = CFG.lineWidthMajor;
    ctx.strokeStyle = `color-mix(in srgb, ${major} ${CFG.majorOpacity*100}%, transparent)`;
    ctx.beginPath();
    for(let i=0;i<=cols;i++){ if(i%CFG.majorEvery===0){ const x=Math.round(i*cell)+.5; ctx.moveTo(x,0); ctx.lineTo(x,rows*cell); } }
    for(let j=0;j<=rows;j++){ if(j%CFG.majorEvery===0){ const y=Math.round(j*cell)+.5; ctx.moveTo(0,y); ctx.lineTo(cols*cell,y); } }
    ctx.stroke();
    ctx.restore();
  }

  /* ==============================
     Traversal (diagonal bands with per-band shuffle)
  ===============================*/
  let order = [];
  const filled = new Set();
  function key(i,j){return `${i},${j}`}

  function composeTraversal(){
    const bands = new Map();
    for(let j=0;j<rows;j++) for(let i=0;i<cols;i++){
      const b=i+j; if(!bands.has(b)) bands.set(b,[]); bands.get(b).push({i,j});
    }
    const keys = [...bands.keys()].sort((a,b)=>a-b);
    for(const k of keys){
      const localRand = mulberry32((SESSION_SEED ^ (k*2654435761))>>>0);
      const arr = bands.get(k);
      for(let t=arr.length-1;t>0;t--){ const j = Math.floor(localRand()*(t+1)); [arr[t],arr[j]]=[arr[j],arr[t]]; }
      order.push(...arr);
    }
  }

  /* ==============================
     Progressive fill with “static” flicker
  ===============================*/
  let animPaused=false, coverageReached=false;
  function scheduleNextBurst(delay){
    if(animPaused) return;
    setTimeout(()=>{
      if(animPaused) return;
      const n = Math.floor(randRange(CFG.burst.min, CFG.burst.max));
      let painted = 0;
      while(painted < n){
        const idx = nextIndex();
        if(idx===-1) break;
        const {i,j} = order[idx];
        if(CFG.skipHero && intersectsHero(i,j)){ filled.add(key(i,j)); continue; }
        flickerThenFill(i,j, intersectsHero(i,j) ? CFG.attenuateUnderHero : 1);
        filled.add(key(i,j));
        painted++;
      }
      const cov = filled.size / order.length;
      coverageReached = cov >= CFG.coverageTarget;
      const next = coverageReached ? randRange(CFG.afterIdlePace.min, CFG.afterIdlePace.max)
                                   : randRange(CFG.pace.min, CFG.pace.max);
      scheduleNextBurst(next);
    }, delay);
  }

  function nextIndex(){
    // probe-random then forward scan to keep variety
    for(let tries=0; tries<16; tries++){
      const start = Math.floor(rand()*order.length);
      for(let k=0;k<order.length;k++){
        const idx=(start+k)%order.length; const c=order[idx];
        if(!filled.has(key(c.i,c.j))) return idx;
      }
    }
    return -1;
  }

  function fillRect(x,y,w,h,color,alpha=1){
    ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.fillRect(x,y,w,h); ctx.restore();
  }

  function flickerThenFill(i,j, alpha=1){
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) {
      return solidFill(i,j,alpha);
    }
    const steps = choice(CFG.flickerSteps);
    const dt = CFG.flickerTotalMs / steps;
    const x=i*cell, y=j*cell, w=cell-1, h=cell-1;
    for(let s=0;s<steps;s++){
      setTimeout(()=>{
        const c = palette[Math.floor(rand()*palette.length)];
        const jx = (rand()*2-1)*CFG.jitterPx;
        const jy = (rand()*2-1)*CFG.jitterPx;
        fillRect(x+1+jx, y+1+jy, w, h, c, 0.30 + 0.20*rand()); // ghosty flicker
      }, s*dt);
    }
    setTimeout(()=> solidFill(i,j,alpha), CFG.flickerTotalMs + 10);
  }

  function solidFill(i,j, alpha=1){
    const x=i*cell, y=j*cell;
    const idx = colorIndex(i,j);
    fillRect(x+1, y+1, cell-1, cell-1, palette[idx], alpha);
  }

  function colorIndex(i,j){
    // deterministic per cell + session
    let h = (i * 374761393 + j * 668265263) ^ SESSION_SEED;
    h ^= h>>>13; h = (h*1274126177)>>>0; return h % palette.length;
  }

  function intersectsHero(i,j){
    const r = heroRect();
    const x=i*cell, y=j*cell, w=cell, h=cell;
    return !(x+w < r.x || x > r.x+r.w || y+h < r.y || y > r.y+r.h);
  }

  /* ==============================
     Overlay: subtle scanline shimmer
  ===============================*/
  let overlayRAF = null, scanY = 0;
  function startOverlay(){
    cancelAnimationFrame(overlayRAF);
    octx.clearRect(0,0,W,H);
    scanY = 0;
    const minor = getComputedStyle(document.documentElement).getPropertyValue('--grid-minor').trim();
    const baseAlpha = 0.05; // ultra subtle

    function tick(){
      octx.clearRect(0,0,W,H);
      // two moving bands
      const bandH = 3;
      octx.fillStyle = `color-mix(in srgb, ${minor} ${baseAlpha*100}%, transparent)`;
      octx.fillRect(0, (scanY% (rows*cell)), W, bandH);
      octx.fillRect(0, ((scanY+60) % (rows*cell)), W, bandH);
      scanY += 1.2; // slow drift
      overlayRAF = requestAnimationFrame(tick);
    }
    if (!matchMedia('(prefers-reduced-motion: reduce)').matches) overlayRAF = requestAnimationFrame(tick);
  }

  /* ==============================
     Reduced-motion: quick static composition
  ===============================*/
  function renderReduced(){
    // Fill to ~60% instantly, no flicker/overlay
    const target = Math.floor(order.length * 0.6);
    for(let n=0;n<target;n++){
      const {i,j} = order[n];
      solidFill(i,j, intersectsHero(i,j) ? CFG.attenuateUnderHero : 1);
      filled.add(key(i,j));
    }
  }

  /* ==============================
     Controls & bootstrap
  ===============================*/
  document.getElementById('regen').addEventListener('click', ()=>{
    SESSION_SEED = (crypto?.getRandomValues) ? crypto.getRandomValues(new Uint32Array(1))[0] : (Date.now()>>>0);
    rand = mulberry32(SESSION_SEED);
    filled.clear(); order.length=0; drawGridPaper(); composeTraversal();
    startOverlay();
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) renderReduced();
    else scheduleNextBurst(0);
  });
  document.getElementById('pause').addEventListener('click', (e)=>{
    animPaused = !animPaused;
    e.currentTarget.textContent = animPaused ? 'Resume' : 'Pause';
    if(!animPaused) scheduleNextBurst(0);
  });

  const debounced = (()=>{ let t; return ()=>{ clearTimeout(t); t=setTimeout(resize,140); };})();
  window.addEventListener('resize', debounced); window.addEventListener('orientationchange', debounced);

  // Go
  resize();
  </script>
</body>
</html>